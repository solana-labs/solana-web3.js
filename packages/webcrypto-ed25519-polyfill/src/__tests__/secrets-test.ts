import '@solana/test-matchers/toBeFrozenObject';

import {
    exportKeyPolyfill,
    generateKeyPolyfill,
    importKeyPolyfill,
    isPolyfilledKey,
    signPolyfill,
    verifyPolyfill,
} from '../secrets';

const MOCK_DATA = new Uint8Array([1, 2, 3]);
const MOCK_DATA_SIGNATURE = new Uint8Array([
    239, 105, 216, 141, 51, 239, 0, 205, 191, 77, 181, 210, 95, 178, 175, 34, 226, 220, 252, 118, 255, 132, 101, 63, 35,
    245, 181, 165, 19, 73, 242, 201, 84, 233, 251, 88, 27, 10, 18, 59, 1, 101, 228, 9, 14, 200, 66, 233, 195, 13, 79,
    72, 48, 6, 161, 22, 137, 127, 73, 135, 139, 150, 125, 11,
]);
const MOCK_SECRET_KEY_BYTES = new Uint8Array([
    83, 147, 250, 112, 140, 37, 29, 73, 156, 38, 185, 76, 163, 8, 178, 225, 172, 53, 120, 108, 127, 191, 103, 8, 160,
    170, 183, 186, 246, 1, 227, 158,
]);
const MOCK_SECRET_KEY_BASE_64_URL = 'U5P6cIwlHUmcJrlMowiy4aw1eGx_v2cIoKq3uvYB454';
const MOCK_PUBLIC_KEY_BYTES = new Uint8Array([
    166, 132, 114, 186, 49, 163, 23, 12, 11, 14, 119, 219, 102, 96, 26, 226, 91, 97, 238, 217, 236, 84, 232, 204, 62,
    212, 179, 252, 20, 37, 179, 52,
]);
const MOCK_PUBLIC_KEY_BASE_64_URL = 'poRyujGjFwwLDnfbZmAa4lth7tnsVOjMPtSz_BQlszQ';
const ED25519_PKCS8_HEADER =
    // prettier-ignore
    [
        /**
         * PKCS#8 header
         */
        0x30, // ASN.1 sequence tag
        0x2e, // Length of sequence (46 more bytes)

            0x02, // ASN.1 integer tag
            0x01, // Length of integer
                0x00, // Version number

            0x30, // ASN.1 sequence tag
            0x05, // Length of sequence
                0x06, // ASN.1 object identifier tag
                0x03, // Length of object identifier
                    // Edwards curve algorithms identifier https://oid-rep.orange-labs.fr/get/1.3.101.112
                        0x2b, // iso(1) / identified-organization(3) (The first node is multiplied by the decimal 40 and the result is added to the value of the second node)
                        0x65, // thawte(101)
                    // Ed25519 identifier
                        0x70, // id-Ed25519(112)

        /**
         * Private key payload
         */
        0x04, // ASN.1 octet string tag
        0x22, // String length (34 more bytes)

            // Private key bytes as octet string
            0x04, // ASN.1 octet string tag
            0x20, // String length (32 bytes)
    ];

describe('exportKeyPolyfill', () => {
    it.each(['spki'] as const)('throws an unimplemented error when the format is %s', async format => {
        expect.assertions(1);
        const mockKey = { format } as unknown as CryptoKey;
        await expect(exportKeyPolyfill(format, mockKey)).rejects.toThrow(/unimplemented/);
    });
    describe('when format is `raw`', () => {
        it('throws when the key supplied is non-extractable', async () => {
            expect.assertions(1);
            const mockKey = { extractable: false, type: 'public' } as unknown as CryptoKey;
            await expect(exportKeyPolyfill('raw', mockKey)).rejects.toThrow('key is not extractable');
        });
        it.each(['private', 'secret'] as KeyType[])('throws when a %s key is supplied', async type => {
            expect.assertions(1);
            const mockKey = { extractable: true, type } as unknown as CryptoKey;
            await expect(exportKeyPolyfill('raw', mockKey)).rejects.toThrow(
                `Unable to export a raw Ed25519 ${type} key`,
            );
        });
        it('throws when supplied a public key that was not generated with the polyfill', async () => {
            expect.assertions(1);
            const { publicKey } = await crypto.subtle.generateKey('Ed25519', /* extractable */ false, [
                'sign',
                'verify',
            ]);
            await expect(exportKeyPolyfill('raw', publicKey)).rejects.toThrow();
        });
        it('returns the public key bytes associated with a secret key generated by the polyfill', async () => {
            expect.assertions(1);
            jest.spyOn(globalThis.crypto, 'getRandomValues').mockReturnValue(MOCK_SECRET_KEY_BYTES);
            const { publicKey } = generateKeyPolyfill(/* extractable */ false, ['sign', 'verify']);
            await expect(exportKeyPolyfill('raw', publicKey)).resolves.toEqual(MOCK_PUBLIC_KEY_BYTES);
        });
    });
    describe('when format is `pkcs8`', () => {
        it('throws when the key supplied is non-extractable', async () => {
            expect.assertions(1);
            const mockKey = { extractable: false, type: 'private' } as unknown as CryptoKey;
            await expect(exportKeyPolyfill('pkcs8', mockKey)).rejects.toThrow('key is not extractable');
        });
        it.each(['public', 'secret'] as KeyType[])('throws when a %s key is supplied', async type => {
            expect.assertions(1);
            const mockKey = { extractable: true, type } as unknown as CryptoKey;
            await expect(exportKeyPolyfill('pkcs8', mockKey)).rejects.toThrow(
                `Unable to export a pkcs8 Ed25519 ${type} key`,
            );
        });
        it('throws when supplied a private key that was not generated with the polyfill', async () => {
            expect.assertions(1);
            const { privateKey } = await crypto.subtle.generateKey('Ed25519', /* extractable */ false, [
                'sign',
                'verify',
            ]);
            await expect(exportKeyPolyfill('pkcs8', privateKey)).rejects.toThrow();
        });
        it('returns the private key bytes associated with a secret key generated by the polyfill with pkcs8 header prepended', async () => {
            expect.assertions(1);
            jest.spyOn(globalThis.crypto, 'getRandomValues').mockReturnValue(MOCK_SECRET_KEY_BYTES);
            const { privateKey } = generateKeyPolyfill(/* extractable */ true, ['sign', 'verify']);
            // prettier-ignore
            const expectedBytes = new Uint8Array([
                /**
                 * PKCS#8 header
                 */
                0x30, // ASN.1 sequence tag
                0x2e, // Length of sequence (46 more bytes)

                    0x02, // ASN.1 integer tag
                    0x01, // Length of integer
                        0x00, // Version number

                    0x30, // ASN.1 sequence tag
                    0x05, // Length of sequence
                        0x06, // ASN.1 object identifier tag
                        0x03, // Length of object identifier
                            // Edwards curve algorithms identifier https://oid-rep.orange-labs.fr/get/1.3.101.112
                                0x2b, // iso(1) / identified-organization(3) (The first node is multiplied by the decimal 40 and the result is added to the value of the second node)
                                0x65, // thawte(101)
                            // Ed25519 identifier
                                0x70, // id-Ed25519(112)

                /**
                 * Private key payload
                 */
                0x04, // ASN.1 octet string tag
                0x22, // String length (34 more bytes)

                    // Private key bytes as octet string
                    0x04, // ASN.1 octet string tag
                    0x20, // String length (32 bytes)
                        83, 147, 250, 112, 140, 37, 29, 73,
                        156, 38, 185, 76, 163, 8, 178, 225,
                        172, 53, 120, 108, 127, 191, 103, 8,
                        160, 170, 183, 186, 246, 1, 227, 158,
            ]);
            await expect(exportKeyPolyfill('pkcs8', privateKey)).resolves.toEqual(expectedBytes);
        });
    });
    describe('when format is `jwk`', () => {
        it('exports public keys', async () => {
            expect.assertions(1);
            jest.spyOn(globalThis.crypto, 'getRandomValues').mockReturnValue(MOCK_SECRET_KEY_BYTES);
            const { publicKey } = generateKeyPolyfill(/* extractable */ false, ['sign', 'verify']);
            const jwk = await exportKeyPolyfill('jwk', publicKey);
            expect(jwk).toEqual({
                crv /* curve */: 'Ed25519',
                ext /* extractable */: true,
                key_ops /* key operations */: ['verify'],
                kty /* key type */: 'OKP' /* octet key pair */,
                x /* public key x-coordinate (base64-URL encoded) */: MOCK_PUBLIC_KEY_BASE_64_URL,
            });
        });
        it('exports private keys', async () => {
            expect.assertions(1);
            jest.spyOn(globalThis.crypto, 'getRandomValues').mockReturnValue(MOCK_SECRET_KEY_BYTES);
            const { privateKey } = generateKeyPolyfill(/* extractable */ true, ['sign', 'verify']);
            const jwk = await exportKeyPolyfill('jwk', privateKey);
            expect(jwk).toEqual({
                crv /* curve */: 'Ed25519',
                d /* private key (base64-URL encoded) */: MOCK_SECRET_KEY_BASE_64_URL,
                ext /* extractable */: true,
                key_ops /* key operations */: ['sign'],
                kty /* key type */: 'OKP' /* octet key pair */,
                x /* public key x-coordinate (base64-URL encoded) */: MOCK_PUBLIC_KEY_BASE_64_URL,
            });
        });
        it('freezes the exported public key', async () => {
            expect.assertions(1);
            jest.spyOn(globalThis.crypto, 'getRandomValues').mockReturnValue(MOCK_SECRET_KEY_BYTES);
            const { publicKey } = generateKeyPolyfill(/* extractable */ false, ['sign', 'verify']);
            const jwk = await exportKeyPolyfill('jwk', publicKey);
            expect(jwk).toBeFrozenObject();
        });
        it('freezes the exported private key', async () => {
            expect.assertions(1);
            jest.spyOn(globalThis.crypto, 'getRandomValues').mockReturnValue(MOCK_SECRET_KEY_BYTES);
            const { privateKey } = generateKeyPolyfill(/* extractable */ true, ['sign', 'verify']);
            const jwk = await exportKeyPolyfill('jwk', privateKey);
            expect(jwk).toBeFrozenObject();
        });
        it('throws when the public key supplied is non-extractable', async () => {
            expect.assertions(1);
            const mockKey = { extractable: false, type: 'public' } as unknown as CryptoKey;
            await expect(exportKeyPolyfill('jwk', mockKey)).rejects.toThrow('key is not extractable');
        });
        it('throws when the private key supplied is non-extractable', async () => {
            expect.assertions(1);
            const mockKey = { extractable: false, type: 'private' } as unknown as CryptoKey;
            await expect(exportKeyPolyfill('jwk', mockKey)).rejects.toThrow('key is not extractable');
        });
    });
});

describe('importKeyPolyfill', () => {
    describe('when format is `raw`', () => {
        it('allows importing valid public key bytes', () => {
            expect(() => importKeyPolyfill('raw', MOCK_PUBLIC_KEY_BYTES, false, ['verify'])).not.toThrow();
        });
        it('allows importing with empty keyUsages', () => {
            expect(() => importKeyPolyfill('raw', MOCK_PUBLIC_KEY_BYTES, false, [])).not.toThrow();
        });
        it.each(['sign', 'decrypt', 'deriveBits', 'deriveKey', 'encrypt', 'unwrapKey', 'wrapKey'] as KeyUsage[])(
            'fatals when the usage `%s` is specified',
            usage => {
                expect(() => importKeyPolyfill('raw', MOCK_PUBLIC_KEY_BYTES, false, [usage])).toThrow(
                    'Unsupported key usage for a Ed25519 key',
                );
            },
        );
        it.each([0, 1, 30, 31, 33, 34, 48])('fatals when bytes is length `%d`', bytesLength => {
            const keyData = new Uint8Array(Array(bytesLength).fill(0));
            expect(() => importKeyPolyfill('raw', keyData, false, ['verify'])).toThrow(
                'Ed25519 raw keys must be exactly 32-bytes',
            );
        });
        it('has the string tag "CryptoKey"', () => {
            const key = importKeyPolyfill('raw', MOCK_PUBLIC_KEY_BYTES, false, ['verify']);
            expect(key).toHaveProperty([Symbol.toStringTag], 'CryptoKey');
        });
        it('has the type "public"', () => {
            const key = importKeyPolyfill('raw', MOCK_PUBLIC_KEY_BYTES, false, ['verify']);
            expect(key).toHaveProperty('type', 'public');
        });
        it.each([true, false])(
            'has extractable `%s` when importing a key with the extractability `%s`',
            extractability => {
                const key = importKeyPolyfill('raw', MOCK_PUBLIC_KEY_BYTES, extractability, ['verify']);
                expect(key).toHaveProperty('extractable', extractability);
            },
        );
        it('has the algorithm "Ed25519"', () => {
            const key = importKeyPolyfill('raw', MOCK_PUBLIC_KEY_BYTES, false, ['verify']);
            expect(key).toHaveProperty(['algorithm', 'name'], 'Ed25519');
        });
        it('has usages `["verify"]`', () => {
            const key = importKeyPolyfill('raw', MOCK_PUBLIC_KEY_BYTES, false, ['verify']);
            expect(key).toHaveProperty('usages', ['verify']);
        });
        it('stores public key bytes in an internal cache', () => {
            const weakMapSetSpy = jest.spyOn(WeakMap.prototype, 'set');
            importKeyPolyfill('raw', MOCK_PUBLIC_KEY_BYTES, false, ['verify']);
            expect(weakMapSetSpy).toHaveBeenCalledWith(expect.anything(), MOCK_PUBLIC_KEY_BYTES);
        });
        it('imported key can be used to verify a signature', async () => {
            expect.assertions(1);
            const key = importKeyPolyfill('raw', MOCK_PUBLIC_KEY_BYTES, false, ['verify']);
            await expect(verifyPolyfill(key, MOCK_DATA_SIGNATURE, MOCK_DATA)).resolves.toBe(true);
        });
        it('imported key correctly does not verify a bad signature', async () => {
            expect.assertions(1);
            const key = importKeyPolyfill('raw', MOCK_PUBLIC_KEY_BYTES, false, ['verify']);
            const badSignature = new Uint8Array(Array(64).fill(0));
            await expect(verifyPolyfill(key, badSignature, MOCK_DATA)).resolves.toBe(false);
        });
        it('imported key can be exported to return the same bytes', async () => {
            expect.assertions(1);
            const key = importKeyPolyfill('raw', MOCK_PUBLIC_KEY_BYTES, /*extractable */ true, ['verify']);
            await expect(exportKeyPolyfill('raw', key)).resolves.toStrictEqual(MOCK_PUBLIC_KEY_BYTES);
        });
        it('can import a public key that was exported from a native generated key', async () => {
            expect.assertions(1);
            const keyPair = await crypto.subtle.generateKey('Ed25519', /* extractable */ true, ['verify', 'sign']);
            const publicKeyBytes = await crypto.subtle.exportKey('raw', keyPair.publicKey);
            expect(() => importKeyPolyfill('raw', publicKeyBytes, false, ['verify'])).not.toThrow();
        });
        it('can import a public key that was exported from a polyfill generated key', async () => {
            expect.assertions(1);
            const keyPair = generateKeyPolyfill(/* extractable */ true, ['verify', 'sign']);
            const publicKeyBytes = await exportKeyPolyfill('raw', keyPair.publicKey);
            expect(() => importKeyPolyfill('raw', publicKeyBytes, false, ['verify'])).not.toThrow();
        });
    });

    describe('when format is `pkcs8`', () => {
        const mockSecretKeyWithHeader = new Uint8Array([...ED25519_PKCS8_HEADER, ...MOCK_SECRET_KEY_BYTES]);

        it('allows importing valid private key bytes', () => {
            expect(() => importKeyPolyfill('pkcs8', mockSecretKeyWithHeader, false, ['sign'])).not.toThrow();
        });
        it('allows importing with empty keyUsages', () => {
            expect(() => importKeyPolyfill('pkcs8', mockSecretKeyWithHeader, false, [])).not.toThrow();
        });
        it.each(['verify', 'decrypt', 'deriveBits', 'deriveKey', 'encrypt', 'unwrapKey', 'wrapKey'] as KeyUsage[])(
            'fatals when the usage `%s` is specified',
            usage => {
                expect(() => importKeyPolyfill('pkcs8', mockSecretKeyWithHeader, false, [usage])).toThrow(
                    'Unsupported key usage for a Ed25519 key',
                );
            },
        );
        it.each([0, 1, 32, 46, 47, 49, 50])('fatals when bytes is length `%d`', bytesLength => {
            const keyData = new Uint8Array(Array(bytesLength).fill(0));
            expect(() => importKeyPolyfill('pkcs8', keyData, false, ['sign'])).toThrow('Invalid keyData');
        });
        it('fatals when the first 16 bytes are not the expected header', () => {
            const keyData = new Uint8Array([...Array(16).fill(0), ...MOCK_SECRET_KEY_BYTES]);
            expect(() => importKeyPolyfill('pkcs8', keyData, false, ['sign'])).toThrow('Invalid keyData');
        });
        it('has the string tag "CryptoKey"', () => {
            const key = importKeyPolyfill('pkcs8', mockSecretKeyWithHeader, false, ['sign']);
            expect(key).toHaveProperty([Symbol.toStringTag], 'CryptoKey');
        });
        it('has the type "private"', () => {
            const key = importKeyPolyfill('pkcs8', mockSecretKeyWithHeader, false, ['sign']);
            expect(key).toHaveProperty('type', 'private');
        });
        it.each([true, false])(
            'has extractable `%s` when importing a key with the extractability `%s`',
            extractability => {
                const key = importKeyPolyfill('pkcs8', mockSecretKeyWithHeader, extractability, ['sign']);
                expect(key).toHaveProperty('extractable', extractability);
            },
        );
        it('has the algorithm "Ed25519"', () => {
            const key = importKeyPolyfill('pkcs8', mockSecretKeyWithHeader, false, ['sign']);
            expect(key).toHaveProperty(['algorithm', 'name'], 'Ed25519');
        });
        it('has usages `["sign"]`', () => {
            const key = importKeyPolyfill('pkcs8', mockSecretKeyWithHeader, false, ['sign']);
            expect(key).toHaveProperty('usages', ['sign']);
        });
        it('stores private key bytes in an internal cache', () => {
            const weakMapSetSpy = jest.spyOn(WeakMap.prototype, 'set');
            importKeyPolyfill('pkcs8', mockSecretKeyWithHeader, false, ['sign']);
            expect(weakMapSetSpy).toHaveBeenCalledWith(expect.anything(), MOCK_SECRET_KEY_BYTES);
        });
        it('imported key can be used to sign data', async () => {
            expect.assertions(1);
            const key = importKeyPolyfill('pkcs8', mockSecretKeyWithHeader, false, ['sign']);
            await expect(signPolyfill(key, MOCK_DATA)).resolves.toStrictEqual(MOCK_DATA_SIGNATURE);
        });
        // we don't have export pkcs8 keys yet
        it('imported key can be exported to return the same bytes', async () => {
            expect.assertions(1);
            const key = importKeyPolyfill('pkcs8', mockSecretKeyWithHeader, /*extractable */ true, ['sign']);
            await expect(exportKeyPolyfill('pkcs8', key)).resolves.toStrictEqual(mockSecretKeyWithHeader);
        });
        it('can import a private key that was exported from a native generated key', async () => {
            expect.assertions(1);
            const { privateKey } = await crypto.subtle.generateKey('Ed25519', /* extractable */ true, [
                'verify',
                'sign',
            ]);
            const privateKeyPkcs8Bytes = await crypto.subtle.exportKey('pkcs8', privateKey);
            expect(() => importKeyPolyfill('pkcs8', privateKeyPkcs8Bytes, false, ['sign'])).not.toThrow();
        });
        it('can import a private key that was exported from a polyfill generated key', async () => {
            expect.assertions(1);
            const { privateKey } = generateKeyPolyfill(/* extractable */ true, ['verify', 'sign']);
            const privateKeyPkcs8Bytes = await exportKeyPolyfill('pkcs8', privateKey);
            expect(() => importKeyPolyfill('pkcs8', privateKeyPkcs8Bytes, false, ['sign'])).not.toThrow();
        });
    });

    describe('when format is `jwk`', () => {
        it('creates public key CryptoKey instances', () => {
            const key = importKeyPolyfill(
                'jwk',
                {
                    crv /* curve */: 'Ed25519',
                    ext /* extractable */: false,
                    key_ops /* key operations */: ['verify'],
                    kty /* key type */: 'OKP' /* octet key pair */,
                    x /* public key x-coordinate (base64-URL encoded) */: MOCK_PUBLIC_KEY_BASE_64_URL,
                },
                false,
                ['verify'],
            );
            expect(key).toEqual({
                [Symbol.toStringTag]: 'CryptoKey',
                algorithm: { name: 'Ed25519' },
                extractable: false,
                type: 'public',
                usages: ['verify'],
            });
        });
        it('creates private key CryptoKey instances', () => {
            const key = importKeyPolyfill(
                'jwk',
                {
                    crv /* curve */: 'Ed25519',
                    d /* private key (base64-URL encoded) */: MOCK_SECRET_KEY_BASE_64_URL,
                    ext /* extractable */: false,
                    key_ops /* key operations */: ['sign'],
                    kty /* key type */: 'OKP' /* octet key pair */,
                    x /* public key x-coordinate (base64-URL encoded) */: MOCK_PUBLIC_KEY_BASE_64_URL,
                },
                false,
                ['sign'],
            );
            expect(key).toEqual({
                [Symbol.toStringTag]: 'CryptoKey',
                algorithm: { name: 'Ed25519' },
                extractable: false,
                type: 'private',
                usages: ['sign'],
            });
        });
        it('freezes the CryptoKey public key', () => {
            const key = importKeyPolyfill(
                'jwk',
                {
                    crv /* curve */: 'Ed25519',
                    ext /* extractable */: false,
                    key_ops /* key operations */: ['verify'],
                    kty /* key type */: 'OKP' /* octet key pair */,
                    x /* public key x-coordinate (base64-URL encoded) */: MOCK_PUBLIC_KEY_BASE_64_URL,
                },
                false,
                ['verify'],
            );
            expect(key).toBeFrozenObject();
        });
        it('freezes the CryptoKey private key', () => {
            const key = importKeyPolyfill(
                'jwk',
                {
                    crv /* curve */: 'Ed25519',
                    d /* private key (base64-URL encoded) */: MOCK_SECRET_KEY_BASE_64_URL,
                    ext /* extractable */: false,
                    key_ops /* key operations */: ['sign'],
                    kty /* key type */: 'OKP' /* octet key pair */,
                    x /* public key x-coordinate (base64-URL encoded) */: MOCK_PUBLIC_KEY_BASE_64_URL,
                },
                false,
                ['sign'],
            );
            expect(key).toBeFrozenObject();
        });
        it('can verify a correct signature using the imported public key', async () => {
            expect.assertions(1);
            const key = importKeyPolyfill(
                'jwk',
                {
                    crv /* curve */: 'Ed25519',
                    ext /* extractable */: false,
                    key_ops /* key operations */: ['verify'],
                    kty /* key type */: 'OKP' /* octet key pair */,
                    x /* public key x-coordinate (base64-URL encoded) */: MOCK_PUBLIC_KEY_BASE_64_URL,
                },
                false,
                ['verify'],
            );
            await expect(verifyPolyfill(key, MOCK_DATA_SIGNATURE, MOCK_DATA)).resolves.toBe(true);
        });
        it('can identify a bad signature using the imported public key', async () => {
            expect.assertions(1);
            const key = importKeyPolyfill(
                'jwk',
                {
                    crv /* curve */: 'Ed25519',
                    ext /* extractable */: false,
                    key_ops /* key operations */: ['verify'],
                    kty /* key type */: 'OKP' /* octet key pair */,
                    x /* public key x-coordinate (base64-URL encoded) */: MOCK_PUBLIC_KEY_BASE_64_URL,
                },
                false,
                ['verify'],
            );
            const badSignature = new Uint8Array(Array(64).fill(0));
            await expect(verifyPolyfill(key, badSignature, MOCK_DATA)).resolves.toBe(false);
        });
        it('can sign using the imported private key', async () => {
            expect.assertions(1);
            const key = importKeyPolyfill(
                'jwk',
                {
                    crv /* curve */: 'Ed25519',
                    d /* private key (base64-URL encoded) */: MOCK_SECRET_KEY_BASE_64_URL,
                    ext /* extractable */: false,
                    key_ops /* key operations */: ['sign'],
                    kty /* key type */: 'OKP' /* octet key pair */,
                    x /* public key x-coordinate (base64-URL encoded) */: MOCK_PUBLIC_KEY_BASE_64_URL,
                },
                false,
                ['sign'],
            );
            await expect(signPolyfill(key, MOCK_DATA)).resolves.toStrictEqual(MOCK_DATA_SIGNATURE);
        });
        it('can import and re-export the same public key', async () => {
            expect.assertions(1);
            const originalJwk = {
                crv /* curve */: 'Ed25519',
                d /* private key (base64-URL encoded) */: MOCK_SECRET_KEY_BASE_64_URL,
                ext /* extractable */: true,
                key_ops /* key operations */: ['sign'],
                kty /* key type */: 'OKP' /* octet key pair */,
                x /* public key x-coordinate (base64-URL encoded) */: MOCK_PUBLIC_KEY_BASE_64_URL,
            };
            const key = importKeyPolyfill('jwk', originalJwk, true, ['sign']);
            const exportedJwk = await exportKeyPolyfill('jwk', key);
            expect(exportedJwk).toEqual(originalJwk);
        });
        it('can import and re-export the same private key', async () => {
            expect.assertions(1);
            const originalJwk = {
                crv /* curve */: 'Ed25519',
                ext /* extractable */: true,
                key_ops /* key operations */: ['verify'],
                kty /* key type */: 'OKP' /* octet key pair */,
                x /* public key x-coordinate (base64-URL encoded) */: MOCK_PUBLIC_KEY_BASE_64_URL,
            };
            const key = importKeyPolyfill('jwk', originalJwk, true, ['verify']);
            const exportedJwk = await exportKeyPolyfill('jwk', key);
            expect(exportedJwk).toEqual(originalJwk);
        });
        it('can import a public key that was exported from a native generated key', async () => {
            expect.assertions(1);
            const { publicKey } = await crypto.subtle.generateKey('Ed25519', /* extractable */ false, [
                'verify',
                'sign',
            ]);
            const jwk = await crypto.subtle.exportKey('jwk', publicKey);
            expect(() => importKeyPolyfill('jwk', jwk, true, ['verify'])).not.toThrow();
        });
        it('can import a private key that was exported from a native generated key', async () => {
            expect.assertions(1);
            const { privateKey } = await crypto.subtle.generateKey('Ed25519', /* extractable */ true, [
                'verify',
                'sign',
            ]);
            const jwk = await crypto.subtle.exportKey('jwk', privateKey);
            expect(() => importKeyPolyfill('jwk', jwk, true, ['sign'])).not.toThrow();
        });
        it('can import a public key that was exported from a polyfill generated key', async () => {
            expect.assertions(1);
            const { publicKey } = generateKeyPolyfill(/* extractable */ false, ['verify', 'sign']);
            const jwk = await exportKeyPolyfill('jwk', publicKey);
            expect(() => importKeyPolyfill('jwk', jwk, true, ['verify'])).not.toThrow();
        });
        it('can import a private key that was exported from a polyfill generated key', async () => {
            expect.assertions(1);
            const { privateKey } = generateKeyPolyfill(/* extractable */ true, ['verify', 'sign']);
            const jwk = await exportKeyPolyfill('jwk', privateKey);
            expect(() => importKeyPolyfill('jwk', jwk, true, ['sign'])).not.toThrow();
        });
        it('throws when the JWK curve is not Ed25519', () => {
            expect(() =>
                importKeyPolyfill(
                    'jwk',
                    {
                        crv /* curve */: 'Ed448',
                        ext /* extractable */: false,
                        key_ops /* key operations */: ['verify'],
                        kty /* key type */: 'OKP' /* octet key pair */,
                        x /* public key x-coordinate (base64-URL encoded) */: MOCK_PUBLIC_KEY_BASE_64_URL,
                    },
                    false,
                    ['verify'],
                ),
            ).toThrow(/Invalid Ed25519 JWK/);
        });
        it('throws when the JWK key type is not OKP', () => {
            expect(() =>
                importKeyPolyfill(
                    'jwk',
                    {
                        crv /* curve */: 'Ed25519',
                        ext /* extractable */: false,
                        key_ops /* key operations */: ['verify'],
                        kty /* key type */: 'EC',
                        x /* public key x-coordinate (base64-URL encoded) */: MOCK_PUBLIC_KEY_BASE_64_URL,
                    },
                    false,
                    ['verify'],
                ),
            ).toThrow(/Invalid Ed25519 JWK/);
        });
        it('throws when the JWK key_ops do not match the key usages', () => {
            expect(() =>
                importKeyPolyfill(
                    'jwk',
                    {
                        crv /* curve */: 'Ed25519',
                        ext /* extractable */: false,
                        key_ops /* key operations */: ['verify', 'sign'],
                        kty /* key type */: 'OKP' /* octet key pair */,
                        x /* public key x-coordinate (base64-URL encoded) */: MOCK_PUBLIC_KEY_BASE_64_URL,
                    },
                    false,
                    ['verify'],
                ),
            ).toThrow(/Invalid Ed25519 JWK/);
        });
        it('throws when the JWK ext boolean do not match the extractable argument', () => {
            expect(() =>
                importKeyPolyfill(
                    'jwk',
                    {
                        crv /* curve */: 'Ed25519',
                        ext /* extractable */: false,
                        key_ops /* key operations */: ['verify'],
                        kty /* key type */: 'OKP' /* octet key pair */,
                        x /* public key x-coordinate (base64-URL encoded) */: MOCK_PUBLIC_KEY_BASE_64_URL,
                    },
                    true,
                    ['verify'],
                ),
            ).toThrow(/Invalid Ed25519 JWK/);
        });
        it.each(['sign', 'decrypt', 'deriveBits', 'deriveKey', 'encrypt', 'unwrapKey', 'wrapKey'] as KeyUsage[])(
            'throws when a public key is trying to use the `%s` usage',
            usage => {
                expect(() =>
                    importKeyPolyfill(
                        'jwk',
                        {
                            crv /* curve */: 'Ed25519',
                            ext /* extractable */: false,
                            key_ops /* key operations */: [usage],
                            kty /* key type */: 'OKP' /* octet key pair */,
                            x /* public key x-coordinate (base64-URL encoded) */: MOCK_PUBLIC_KEY_BASE_64_URL,
                        },
                        false,
                        [usage],
                    ),
                ).toThrow('Unsupported key usage for a Ed25519 key');
            },
        );
        it.each(['verify', 'decrypt', 'deriveBits', 'deriveKey', 'encrypt', 'unwrapKey', 'wrapKey'] as KeyUsage[])(
            'throws when a private key is trying to use the `%s` usage',
            usage => {
                expect(() =>
                    importKeyPolyfill(
                        'jwk',
                        {
                            crv /* curve */: 'Ed25519',
                            d /* private key (base64-URL encoded) */: MOCK_SECRET_KEY_BASE_64_URL,
                            ext /* extractable */: false,
                            key_ops /* key operations */: [usage],
                            kty /* key type */: 'OKP' /* octet key pair */,
                            x /* public key x-coordinate (base64-URL encoded) */: MOCK_PUBLIC_KEY_BASE_64_URL,
                        },
                        false,
                        [usage],
                    ),
                ).toThrow('Unsupported key usage for a Ed25519 key');
            },
        );
        it('throws when a public key is missing the `x` property', () => {
            expect(() =>
                importKeyPolyfill(
                    'jwk',
                    {
                        crv /* curve */: 'Ed25519',
                        ext /* extractable */: false,
                        key_ops /* key operations */: ['verify'],
                        kty /* key type */: 'OKP' /* octet key pair */,
                    },
                    false,
                    ['verify'],
                ),
            ).toThrow(/Ed25519 JWK is missing public key coordinates/);
        });
        it('throws when a private key is missing the `d` property', () => {
            expect(() =>
                importKeyPolyfill(
                    'jwk',
                    {
                        crv /* curve */: 'Ed25519',
                        d: /* private key (base64-URL encoded) */ undefined,
                        ext /* extractable */: false,
                        key_ops /* key operations */: ['sign'],
                        kty /* key type */: 'OKP' /* octet key pair */,
                        x /* public key x-coordinate (base64-URL encoded) */: MOCK_PUBLIC_KEY_BASE_64_URL,
                    },
                    false,
                    ['sign'],
                ),
            ).toThrow(/Ed25519 JWK is missing private key coordinates/);
        });
    });

    it('fatals when format is spki', () => {
        expect(() => importKeyPolyfill('spki', new Uint8Array(), false, ['sign'])).toThrow(/format is unimplemented/);
    });
});

describe('generateKeyPolyfill', () => {
    it('stores secret key bytes in an internal cache', () => {
        const weakMapSetSpy = jest.spyOn(WeakMap.prototype, 'set');
        const expectedSecretKey = new Uint8Array(Array(32).fill(1));
        jest.spyOn(globalThis.crypto, 'getRandomValues').mockReturnValue(expectedSecretKey);
        generateKeyPolyfill(/* extractable */ false, ['sign', 'verify']);
        expect(weakMapSetSpy).toHaveBeenCalledWith(expect.anything(), expectedSecretKey);
    });
    describe.each(['public', 'private'])('when generating a %s key', type => {
        let keyPair: CryptoKeyPair;
        beforeEach(() => {
            keyPair = generateKeyPolyfill(/* extractable */ false, ['sign', 'verify']);
        });
        it(`has the algorithm "Ed25519"`, () => {
            expect(keyPair).toHaveProperty([`${type}Key`, 'algorithm', 'name'], 'Ed25519');
        });
        it('has the string tag "CryptoKey"', () => {
            expect(keyPair).toHaveProperty([`${type}Key`, Symbol.toStringTag], 'CryptoKey');
        });
        it(`has the type "${type}"`, () => {
            expect(keyPair).toHaveProperty([`${type}Key`, 'type'], type);
        });
    });
    it.each([true, false])(
        "sets the private key's `extractable` accordingly when generating a key pair with the extractability `%s`",
        extractable => {
            const { privateKey } = generateKeyPolyfill(extractable, ['sign', 'verify']);
            expect(privateKey).toHaveProperty('extractable', extractable);
        },
    );
    it.each([true, false])(
        "sets the public key's `extractable` to `true` when generating a key pair with the extractability `%s`",
        extractable => {
            const { publicKey } = generateKeyPolyfill(extractable, ['sign', 'verify']);
            expect(publicKey).toHaveProperty('extractable', true);
        },
    );
    it.each(['decrypt', 'deriveBits', 'deriveKey', 'encrypt', 'unwrapKey', 'wrapKey'] as KeyUsage[])(
        'fatals when the usage `%s` is specified',
        usage => {
            expect(() => generateKeyPolyfill(/* extractable */ false, [usage])).toThrow();
        },
    );
    it("includes `sign` among the private key's usages when the `sign` usage is specified", () => {
        const { privateKey } = generateKeyPolyfill(/* extractable */ false, ['sign']);
        expect(privateKey).toHaveProperty('usages', expect.arrayContaining(['sign']));
    });
    it("sets the private key's usages to an empty array when the `sign` usage is not specified", () => {
        const { privateKey } = generateKeyPolyfill(/* extractable */ false, ['verify']);
        expect(privateKey).toHaveProperty('usages', []);
    });
    it("does not include `verify` among the private key's usages when the `verify` usage is specified", () => {
        const { privateKey } = generateKeyPolyfill(/* extractable */ false, ['verify']);
        expect(privateKey).toHaveProperty('usages', []);
    });
    it("does not include `sign` among the public key's usages when the `sign` usage is specified", () => {
        const { publicKey } = generateKeyPolyfill(/* extractable */ false, ['sign']);
        expect(publicKey).toHaveProperty('usages', []);
    });
    it("sets the public key's usages to an empty array when the `verify` usage is not specified", () => {
        const { publicKey } = generateKeyPolyfill(/* extractable */ false, ['sign']);
        expect(publicKey).toHaveProperty('usages', []);
    });
    it("includes `verify` among the public key's usages when the `verify` usage is specified", () => {
        const { publicKey } = generateKeyPolyfill(/* extractable */ false, ['verify']);
        expect(publicKey).toHaveProperty('usages', expect.arrayContaining(['verify']));
    });
    it('fatals when no key usages are specified', () => {
        expect(() => generateKeyPolyfill(/* extractable */ false, [])).toThrow();
    });
    describe('when no CSPRNG can be found', () => {
        let oldGetRandomValues: Crypto['getRandomValues'];
        beforeEach(() => {
            oldGetRandomValues = globalThis.crypto.getRandomValues;
            // eslint-disable-next-line @typescript-eslint/ban-ts-comment
            // @ts-ignore
            globalThis.crypto.getRandomValues = undefined;
        });
        afterEach(() => {
            globalThis.crypto.getRandomValues = oldGetRandomValues;
        });
        it('fatals', () => {
            expect(() => {
                generateKeyPolyfill(/* extractable */ false, ['sign', 'verify']);
            }).toThrow();
        });
    });
});

describe('isPolyfilledKey', () => {
    it('returns true when given a public key produced with generateKeyPolyfill()', () => {
        const key = generateKeyPolyfill(/* extractable */ false, ['sign', 'verify']);
        expect(isPolyfilledKey(key.publicKey)).toBe(true);
    });
    it('returns true when given a private key produced with generateKeyPolyfill()', () => {
        const key = generateKeyPolyfill(/* extractable */ false, ['sign', 'verify']);
        expect(isPolyfilledKey(key.privateKey)).toBe(true);
    });
    it('returns false when given a public key produced with the native keygen', async () => {
        expect.assertions(1);
        const key = await crypto.subtle.generateKey('Ed25519', /* extractable */ false, ['sign', 'verify']);
        expect(isPolyfilledKey(key.publicKey)).toBe(false);
    });
    it('returns false when given a private key produced with the native keygen', async () => {
        expect.assertions(1);
        const key = await crypto.subtle.generateKey('Ed25519', /* extractable */ false, ['sign', 'verify']);
        expect(isPolyfilledKey(key.privateKey)).toBe(false);
    });
    it('returns true when given a public key produced with importKeyPolyfill', () => {
        const key = importKeyPolyfill('raw', MOCK_PUBLIC_KEY_BYTES, false, ['verify']);
        expect(isPolyfilledKey(key)).toBe(true);
    });
    it('returns false when given a public key produced with the native importKey', async () => {
        expect.assertions(1);
        const key = await crypto.subtle.importKey('raw', MOCK_PUBLIC_KEY_BYTES, 'Ed25519', false, ['verify']);
        expect(isPolyfilledKey(key)).toBe(false);
    });
    it('returns true when given a private key produced with importKeyPolyfill', () => {
        const mockSecretKeyWithHeader = new Uint8Array([...ED25519_PKCS8_HEADER, ...MOCK_SECRET_KEY_BYTES]);
        const key = importKeyPolyfill('pkcs8', mockSecretKeyWithHeader, false, ['sign']);
        expect(isPolyfilledKey(key)).toBe(true);
    });
    it('returns false when given a private key produced with the native importKey', async () => {
        expect.assertions(1);
        const mockSecretKeyWithHeader = new Uint8Array([...ED25519_PKCS8_HEADER, ...MOCK_SECRET_KEY_BYTES]);
        const key = await crypto.subtle.importKey('pkcs8', mockSecretKeyWithHeader, 'Ed25519', false, ['sign']);
        expect(isPolyfilledKey(key)).toBe(false);
    });
});

describe('signPolyfill', () => {
    let privateKey: CryptoKey;
    beforeEach(() => {
        jest.spyOn(globalThis.crypto, 'getRandomValues').mockReturnValue(MOCK_SECRET_KEY_BYTES);
        privateKey = generateKeyPolyfill(/* extractable */ false, ['sign', 'verify']).privateKey;
    });
    it('throws when the key supplied has no "sign" usage', async () => {
        expect.assertions(1);
        const mockKey = { type: 'private', usages: ['verify'] } as unknown as CryptoKey;
        await expect(signPolyfill(mockKey, MOCK_DATA)).rejects.toThrow(/Unable to use this key to sign/);
    });
    it.each(['public', 'secret'] as KeyType[])('throws when a %s key is supplied', async type => {
        expect.assertions(1);
        const mockKey = { type, usages: ['sign'] } as unknown as CryptoKey;
        await expect(signPolyfill(mockKey, MOCK_DATA)).rejects.toThrow(/Unable to use this key to sign/);
    });
    it('produces the expected signature given a private key', async () => {
        expect.assertions(1);
        await expect(signPolyfill(privateKey, MOCK_DATA)).resolves.toEqual(MOCK_DATA_SIGNATURE);
    });
    it('produces signatures 64 bytes in length', async () => {
        expect.assertions(1);
        await expect(signPolyfill(privateKey, MOCK_DATA)).resolves.toHaveLength(64);
    });
});

describe('verifyPolyfill', () => {
    let publicKey: CryptoKey;
    beforeEach(() => {
        jest.spyOn(globalThis.crypto, 'getRandomValues').mockReturnValue(MOCK_SECRET_KEY_BYTES);
        publicKey = generateKeyPolyfill(/* extractable */ false, ['sign', 'verify']).publicKey;
    });
    it('throws when the key supplied has no "verify" usage', async () => {
        expect.assertions(1);
        const mockKey = { type: 'public', usages: ['sign'] } as unknown as CryptoKey;
        const mockSignature = new Uint8Array(Array(64).fill(1));
        await expect(verifyPolyfill(mockKey, mockSignature, MOCK_DATA)).rejects.toThrow(
            /Unable to use this key to verify/,
        );
    });
    it.each(['private', 'secret'] as KeyType[])('throws when a %s key is supplied', async type => {
        expect.assertions(1);
        const mockKey = { type, usages: ['verify'] } as unknown as CryptoKey;
        const mockSignature = new Uint8Array(Array(64).fill(1));
        await expect(verifyPolyfill(mockKey, mockSignature, MOCK_DATA)).rejects.toThrow(
            /Unable to use this key to verify/,
        );
    });
    it('returns `true` when the correct signature is supplied for a given payload', async () => {
        expect.assertions(1);
        await expect(verifyPolyfill(publicKey, MOCK_DATA_SIGNATURE, MOCK_DATA)).resolves.toBe(true);
    });
    it('returns `false` when a bad signature is supplied for a given payload', async () => {
        expect.assertions(1);
        const badSignature = new Uint8Array(Array(64).fill(1));
        await expect(verifyPolyfill(publicKey, badSignature, MOCK_DATA)).resolves.toBe(false);
    });
    it('returns `false` when the signature 65 bytes long', async () => {
        expect.assertions(1);
        const badSignature = new Uint8Array([...MOCK_DATA_SIGNATURE, 1]);
        await expect(verifyPolyfill(publicKey, badSignature, MOCK_DATA)).resolves.toBe(false);
    });
    it('returns `false` when the signature 63 bytes long', async () => {
        expect.assertions(1);
        const badSignature = MOCK_DATA_SIGNATURE.slice(0, 63);
        await expect(verifyPolyfill(publicKey, badSignature, MOCK_DATA)).resolves.toBe(false);
    });
});
